# Story 1.7: Implement Operator Communication Tool

**Status**: Ready

---

## Story

**As a** Researcher,
**I want** the agent to be able to send me synchronous messages and wait for my response,
**so that** I can interact with it during an experiment as the operator.

---

## Acceptance Criteria

1. A `send_message_to_operator` function is implemented
2. When invoked by the `ToolDispatcher`, the function prints the agent's message to the console
3. The script then blocks and waits for the operator to type a response and press Enter
4. The text entered by the operator is returned as the output of the tool call

---

## Tasks / Subtasks

- [ ] **Task 1: Create Operator Communication Module** (AC: 1, 2, 3, 4)
  - [ ] Create file `contreact_ollama/tools/operator_communication.py`
  - [ ] Implement `send_message_to_operator(message: str) -> str` function
  - [ ] Print agent message with `[AGENT]:` prefix
  - [ ] Use `input()` to block and wait for operator response
  - [ ] Prompt operator with `[OPERATOR]:` prefix
  - [ ] Return operator's text input
  - [ ] Add comprehensive docstring

- [ ] **Task 2: Integrate with ToolDispatcher** (AC: 1, 2, 3, 4)
  - [ ] Update ToolDispatcher to import send_message_to_operator
  - [ ] Add to tool registry dictionary
  - [ ] Add to get_tool_definitions() JSON schemas
  - [ ] Test dispatch mechanism

- [ ] **Task 3: Define Tool JSON Schema** (AC: 1)
  - [ ] Create JSON schema for send_message_to_operator tool
  - [ ] Define message parameter as required string
  - [ ] Add descriptive text for LLM understanding
  - [ ] Include in tool definitions list

- [ ] **Task 4: Testing** (AC: 1, 2, 3, 4)
  - [ ] Write unit tests for send_message_to_operator
  - [ ] Mock input() for automated testing
  - [ ] Test console output formatting
  - [ ] Test ToolDispatcher integration
  - [ ] Manual test with actual user interaction

---

## Dev Notes

### Previous Story Insights
From Story 1.6:
- ToolDispatcher created with tool registry pattern
- Tool definitions follow Ollama JSON schema format
- Tools integrated via ExperimentRunner.initialize_services()

### Component Specifications
**Source**: [docs/architecture/components.md#8-operator-communication-tool]

Complete send_message_to_operator function:

```python
def send_message_to_operator(message: str) -> str:
    """
    Send synchronous message to human operator and wait for response.
    
    Args:
        message: The agent's message to the operator
        
    Returns:
        The operator's text response
        
    Implementation:
        - Print message to console with [AGENT]: prefix
        - Block and wait for operator input with [OPERATOR]: prompt
        - Return operator's entered text
    """
    print(f"[AGENT]: {message}")
    response = input("[OPERATOR]: ")
    return response
```

### File Locations
**Source**: [docs/architecture/unified-project-structure.md]

Exact file paths:
- **Operator Communication**: `contreact_ollama/tools/operator_communication.py`
- **Update**: `contreact_ollama/tools/tool_dispatcher.py` (add tool to registry)

### Implementation Details

**send_message_to_operator Implementation**:

```python
def send_message_to_operator(message: str) -> str:
    """
    Send synchronous message to human operator and wait for response.
    
    This function enables bidirectional communication between the agent
    and the human operator during experimental runs. The agent can ask
    questions, provide status updates, or request guidance.
    
    Args:
        message: The agent's message to display to the operator.
                 This should be a clear, well-formatted question or statement.
        
    Returns:
        The operator's text response. Returns exactly what the operator types.
        
    Example:
        >>> response = send_message_to_operator("Should I continue with task X?")
        [AGENT]: Should I continue with task X?
        [OPERATOR]: Yes, please proceed
        >>> print(response)
        'Yes, please proceed'
        
    Note:
        This function blocks execution until the operator provides input.
        The console output uses [AGENT]: and [OPERATOR]: prefixes for clarity.
    """
    print(f"[AGENT]: {message}")
    response = input("[OPERATOR]: ")
    return response
```

**Message Format Specification**:
- **Agent messages**: Always prefixed with `[AGENT]: `
- **Operator prompt**: Always prefixed with `[OPERATOR]: `
- **Purpose**: Clear visual distinction between agent and human in console output

### ToolDispatcher Integration

Update `contreact_ollama/tools/tool_dispatcher.py`:

```python
from contreact_ollama.tools.operator_communication import send_message_to_operator

class ToolDispatcher:
    """Manage and invoke the suite of tools available to the agent."""
    
    def __init__(self, memory_tools: 'MemoryTools'):
        """
        Initialize with memory tools instance.
        
        Args:
            memory_tools: Instance of MemoryTools for persistent storage
        """
        self.memory_tools = memory_tools
        
        # Tool registry mapping tool names to functions
        self.tools: Dict[str, Callable] = {
            "write": self.memory_tools.write,
            "read": self.memory_tools.read,
            "list": self.memory_tools.list,
            "delete": self.memory_tools.delete,
            "pattern_search": self.memory_tools.pattern_search,
            "send_message_to_operator": send_message_to_operator  # Added in Story 1.7
        }
```

Update `get_tool_definitions()` in ToolDispatcher:

```python
def get_tool_definitions(self) -> List[Dict[str, Any]]:
    """
    Generate JSON schema definitions for all available tools.
    
    Returns:
        List of tool definitions in JSON Schema format for Ollama
    """
    return [
        # ... (existing 5 memory tools)
        {
            "type": "function",
            "function": {
                "name": "send_message_to_operator",
                "description": "Send a synchronous message to the human operator and wait for their response. Use this to ask questions, report findings, or request guidance.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "message": {
                            "type": "string",
                            "description": "The message to send to the operator. Should be a clear question or statement."
                        }
                    },
                    "required": ["message"]
                }
            }
        }
    ]
```

### Example Usage Scenarios

**Scenario 1: Agent asks for clarification**
```
[AGENT]: I found conflicting information. Should I prioritize source A or source B?
[OPERATOR]: Use source A
Tool returns: "Use source A"
```

**Scenario 2: Agent reports progress**
```
[AGENT]: I've completed the analysis. Should I proceed with the next task?
[OPERATOR]: Yes, continue
Tool returns: "Yes, continue"
```

**Scenario 3: Agent requests guidance**
```
[AGENT]: I'm stuck on this problem. Can you provide a hint?
[OPERATOR]: Try breaking it into smaller steps
Tool returns: "Try breaking it into smaller steps"
```

### Import Organization
**Source**: [docs/architecture/coding-standards.md#3-code-formatting]

For `contreact_ollama/tools/operator_communication.py`:
```python
# Standard library imports
# (none for this file)

# Third-party imports
# (none for this file)

# Local application imports
# (none for this file)
```

For updated `contreact_ollama/tools/tool_dispatcher.py`:
```python
# Standard library imports
from typing import Dict, List, Any, Callable

# Third-party imports
# (none for this file)

# Local application imports
from contreact_ollama.tools.memory_tools import MemoryTools
from contreact_ollama.tools.operator_communication import send_message_to_operator
```

### Coding Standards
**Source**: [docs/architecture/coding-standards.md]

**Type Hints Required**:
- Function parameter: `message: str`
- Return type: `-> str`

**Docstrings Required**:
- Function-level docstring with Args, Returns, Example, and Note sections
- Explain blocking behavior
- Show example console interaction

**Implementation Notes**:
- Use Python's built-in `input()` function (no external dependencies)
- Function should be simple and stateless
- No error handling needed (input() handles most edge cases)
- Return exactly what operator types (no trimming or modification)

### Console Interaction Example

When agent calls the tool during a cycle:

```
Cycle 3 starting...
[AGENT]: I've analyzed the data and found 3 potential patterns. Which should I investigate first: pattern A (frequency-based), pattern B (temporal), or pattern C (spatial)?
[OPERATOR]: pattern B
Cycle 3 finished.
```

The agent receives "pattern B" as the tool result and can use it in subsequent reasoning.

---

## Testing

**Source**: [docs/architecture/coding-standards.md#8-testing-standards]

### Test Standards for This Story
- **Test Coverage Target**: >80% code coverage
- **Test Framework**: pytest 8.2.2+
- **Test File Location**: `tests/unit/test_operator_communication.py`

### Testing Requirements for Story 1.7

**Unit Tests** (`tests/unit/test_operator_communication.py`):

1. **test_send_message_prints_agent_prefix**
   - Mock print() function
   - Call send_message_to_operator("test message")
   - Assert print called with "[AGENT]: test message"

2. **test_send_message_prompts_operator**
   - Mock input() to return "test response"
   - Call send_message_to_operator("question")
   - Assert input() called with "[OPERATOR]: "

3. **test_send_message_returns_operator_input**
   - Mock input() to return "operator response"
   - Call send_message_to_operator("message")
   - Assert function returns "operator response"

4. **test_send_message_handles_empty_input**
   - Mock input() to return ""
   - Call send_message_to_operator("message")
   - Assert function returns empty string (valid)

5. **test_send_message_handles_multiline_message**
   - Call send_message_to_operator with newline-containing message
   - Assert message printed correctly
   - Assert function still works

**Integration Tests with ToolDispatcher** (`tests/unit/test_tool_dispatcher.py`):

1. **test_dispatcher_includes_operator_communication_tool**
   - Create ToolDispatcher
   - Assert "send_message_to_operator" in tools registry
   - Assert callable

2. **test_dispatcher_can_invoke_operator_tool**
   - Mock input() to return "test response"
   - Call dispatcher.dispatch("send_message_to_operator", {"message": "test"})
   - Assert returns "test response"

3. **test_get_tool_definitions_includes_operator_tool**
   - Call get_tool_definitions()
   - Assert 6 tool definitions returned (5 memory + 1 operator)
   - Find send_message_to_operator definition
   - Assert has correct schema structure

**Mock Strategy Example**:

```python
from unittest.mock import patch, call
import pytest
from contreact_ollama.tools.operator_communication import send_message_to_operator

def test_send_message_prints_agent_prefix_and_returns_input():
    with patch('builtins.print') as mock_print, \
         patch('builtins.input', return_value='operator response') as mock_input:
        
        result = send_message_to_operator("What should I do?")
        
        # Verify print called with agent prefix
        mock_print.assert_called_once_with("[AGENT]: What should I do?")
        
        # Verify input called with operator prompt
        mock_input.assert_called_once_with("[OPERATOR]: ")
        
        # Verify operator's response returned
        assert result == "operator response"
```

**Testing Challenges**:

Since this function uses `input()` which blocks for user input, automated tests must:
1. **Mock input()**: Use `unittest.mock.patch('builtins.input')` to simulate operator responses
2. **Mock print()**: Use `unittest.mock.patch('builtins.print')` to verify console output
3. **Test variations**: Test with different message types, empty responses, special characters

### Manual Testing Checklist

Before marking story complete:
- [ ] Create simple Python script that calls send_message_to_operator
- [ ] Verify `[AGENT]:` prefix appears in console
- [ ] Verify `[OPERATOR]:` prompt appears
- [ ] Type a response and press Enter
- [ ] Verify response is returned correctly
- [ ] Test with empty input (just press Enter)
- [ ] Test with long message (multiple sentences)
- [ ] Test with special characters (!@#$%^&*)
- [ ] Integrate with ToolDispatcher.dispatch()
- [ ] Verify tool appears in get_tool_definitions() output

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-08 | 1.0 | Initial story creation | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by dev agent during implementation*

### Debug Log References
*To be populated by dev agent during implementation*

### Completion Notes List
*To be populated by dev agent during implementation*

### File List
*To be populated by dev agent during implementation*

---

## QA Results
*To be populated by QA agent after implementation*
