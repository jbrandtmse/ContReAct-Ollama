---
story_id: "3.2"
title: "Telegram Bot Service & README Documentation"
epic: 3
status: "Done"
dependencies: ["3.1"]
estimated_points: 8
---

# Story 3.2: Telegram Bot Service & README Documentation

**As a** Researcher, **I want** a Telegram bot service that can send messages and receive operator responses, **so that** I can interact with long-running experiments remotely without being at the terminal.

## Acceptance Criteria

### Telegram Service Implementation

1. New module `contreact_ollama/communication/telegram_service.py` is created
2. `TelegramOperatorChannel` class is implemented with the following methods:
   - `__init__`: Initialize bot with token from environment variable
   - `send_message()`: Post messages to authorized users
   - `wait_for_response()`: Wait for operator response with configurable timeout
   - Connection health check method executed before first use
3. Message formatting includes experiment context (run_id, cycle number)
4. Response validation ensures messages come from authorized users only
5. Connection errors are caught and handled gracefully
6. Fallback to terminal occurs when Telegram connection fails
7. Unit tests are created with mocked Telegram bot API

### README Documentation

8. README.md includes new section: "Telegram Integration for Remote Operator Communication"
9. README section contains all 10 required subsections:
   - Overview (feature explanation, benefits, optional nature)
   - Prerequisites (Telegram account, python-telegram-bot library)
   - Creating Your Telegram Bot (BotFather step-by-step)
   - Setting Up Environment Variables (.env file, system variables)
   - Finding Your Telegram User ID (methods and tools)
   - Configuring in Streamlit UI (navigation and settings)
   - Testing Your Setup (test experiment, verification, troubleshooting)
   - Security Best Practices (token handling, authorized users, monitoring)
   - Example Configuration (YAML snippet)
   - Fallback Behavior (timeout, error handling, notifications)

## Tasks / Subtasks

- [x] Create communication module structure (AC: 1)
  - [x] Create `contreact_ollama/communication/` directory
  - [x] Create `contreact_ollama/communication/__init__.py`
  - [x] Create `contreact_ollama/communication/telegram_service.py`
- [x] Implement TelegramOperatorChannel class (AC: 2, 3, 4, 5, 6)
  - [x] Add `python-telegram-bot` to dependencies in `pyproject.toml`
  - [x] Implement `__init__` method with bot initialization from TELEGRAM_BOT_TOKEN
  - [x] Implement `send_message(message: str, run_id: str, cycle_number: int)` method
  - [x] Implement `wait_for_response(timeout_minutes: int)` method with timeout logic
  - [x] Implement `check_connection()` health check method
  - [x] Implement `_validate_user(user_id: int)` authorization check method
  - [x] Add error handling for connection failures (RequestException, NetworkError)
  - [x] Add fallback logic to raise exception for terminal fallback
  - [x] Format messages with experiment context (run_id, cycle number)
  - [x] Validate incoming messages are from authorized users
  - [x] Add logging for all operations (INFO, WARNING, ERROR levels)
- [x] Unit testing (AC: 7)
  - [x] Create `tests/unit/test_telegram_service.py`
  - [x] Write test for successful bot initialization
  - [x] Write test for missing TELEGRAM_BOT_TOKEN
  - [x] Write test for send_message success
  - [x] Write test for send_message connection failure
  - [x] Write test for wait_for_response success (authorized user)
  - [x] Write test for wait_for_response unauthorized user rejection
  - [x] Write test for wait_for_response timeout
  - [x] Write test for connection health check success/failure
  - [x] Mock telegram.Bot API for all tests
  - [x] Achieve >80% code coverage for telegram_service.py
- [x] README Documentation (AC: 8, 9)
  - [x] Add "Telegram Integration for Remote Operator Communication" section to README.md
  - [x] Write Overview subsection
  - [x] Write Prerequisites subsection
  - [x] Write Creating Your Telegram Bot subsection (BotFather instructions)
  - [x] Write Setting Up Environment Variables subsection
  - [x] Write Finding Your Telegram User ID subsection
  - [x] Write Configuring in Streamlit UI subsection
  - [x] Write Testing Your Setup subsection
  - [x] Write Security Best Practices subsection
  - [x] Write Example Configuration subsection (YAML snippet)
  - [x] Write Fallback Behavior subsection

## Dev Notes

### Previous Story Insights

From Story 3.1, we have:
- `ExperimentConfig` dataclass extended with Telegram fields: `telegram_enabled`, `telegram_authorized_users`, `telegram_timeout_minutes`
- Environment variable `TELEGRAM_BOT_TOKEN` handling pattern established
- Validation pattern in `config.py` for Telegram configuration
- InvalidConfigurationError exception class available for configuration errors
- Security best practices documented in README

### Tech Stack

[Source: docs/architecture/tech-stack.md]

**New Dependency to Add:**
- `python-telegram-bot` (latest stable version, e.g., 20.0+) - Official Python wrapper for Telegram Bot API

**Existing Stack:**
- Python 3.9+ backend
- pytest 8.2.2+ for testing
- Python logging (built-in) for application logging

### Project Structure

[Source: docs/architecture/unified-project-structure.md]

**New Directory Structure:**
```
contreact_ollama/
├── communication/          # NEW - Communication channel implementations
│   ├── __init__.py
│   └── telegram_service.py # NEW - Telegram bot service
```

**Note:** The architecture doc shows the current structure has:
- `contreact_ollama/tools/operator_communication.py` - existing terminal-based operator communication
- This story creates a NEW `communication/` directory for the Telegram service
- Story 3.3 will integrate these into a unified abstraction

**Test Structure:**
```
tests/
└── unit/
    └── test_telegram_service.py  # NEW - Unit tests for Telegram service
```

### Data Models

[Source: docs/architecture/data-models.md, contreact_ollama/core/config.py]

**ExperimentConfig (from Story 3.1):**
```python
@dataclass
class ExperimentConfig:
    # ... existing fields ...
    telegram_enabled: bool = False
    telegram_authorized_users: List[int] = field(default_factory=list)
    telegram_timeout_minutes: int = 5  # -1 = wait forever
```

**Environment Variable:**
- `TELEGRAM_BOT_TOKEN`: Bot token obtained from BotFather, stored as environment variable

### Coding Standards

[Source: docs/architecture/coding-standards.md]

**Type Hints Required:**
```python
from typing import List, Optional
import os

class TelegramOperatorChannel:
    def __init__(self, authorized_users: List[int], timeout_minutes: int = 5) -> None:
        """Initialize Telegram bot service."""
        pass
    
    def send_message(self, message: str, run_id: str, cycle_number: int) -> None:
        """Send message to authorized users with experiment context."""
        pass
    
    def wait_for_response(self, timeout_minutes: int) -> str:
        """Wait for operator response with timeout."""
        pass
```

**Error Handling:**
```python
# Specific exceptions for different failure modes
from telegram.error import NetworkError, TelegramError

try:
    bot.send_message(chat_id, message)
except NetworkError as e:
    logger.error(f"Telegram connection failed: {e}")
    raise ConnectionError("Telegram service unavailable, falling back to terminal")
except TelegramError as e:
    logger.error(f"Telegram API error: {e}")
    raise RuntimeError(f"Failed to send Telegram message: {e}")
```

**Logging Pattern:**
```python
import logging

logger = logging.getLogger(__name__)

def send_message(self, message: str, run_id: str, cycle_number: int) -> None:
    logger.info(f"Sending Telegram message for run {run_id}, cycle {cycle_number}")
    # ... implementation ...
    logger.info(f"Message sent successfully to {len(self.authorized_users)} users")
```

**Docstrings (Google-style):**
```python
def wait_for_response(self, timeout_minutes: int) -> str:
    """
    Wait for operator response via Telegram with timeout.
    
    Args:
        timeout_minutes: Minutes to wait before timeout. -1 means wait forever.
        
    Returns:
        Operator's text response.
        
    Raises:
        TimeoutError: If timeout expires before response received.
        ValueError: If response is from unauthorized user.
        ConnectionError: If Telegram connection fails.
        
    Example:
        >>> channel = TelegramOperatorChannel([123456789], timeout_minutes=5)
        >>> response = channel.wait_for_response(5)
        'Yes, proceed with task'
    """
    pass
```

### Backend Architecture

[Source: docs/architecture/backend-architecture.md]

**Module Organization:**
- New `communication/` package follows separation of concerns
- Dependency injection pattern: TelegramOperatorChannel receives authorized_users and timeout via constructor
- Interface abstraction: TelegramOperatorChannel provides clean abstraction over python-telegram-bot library

**Class Responsibility:**
- `TelegramOperatorChannel`: Encapsulates all Telegram bot operations
- Single responsibility: Sending messages and receiving responses via Telegram
- No business logic - pure communication channel

### Implementation Guidance

**Message Formatting:**
Messages sent to Telegram should include experiment context:
```
🤖 Agent Message (Run: experiment-001, Cycle: 5)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Should I continue analyzing the dataset?
```

**Response Validation:**
- Check incoming message sender's user_id against authorized_users list
- Reject messages from unauthorized users with warning log
- Return only the text content of validated messages

**Timeout Behavior:**
- If timeout_minutes = -1: Wait indefinitely (no timeout)
- If timeout_minutes > 0: Wait specified minutes, then raise TimeoutError
- On timeout: Log warning and raise exception for fallback handling

**Connection Health Check:**
- Call `bot.get_me()` to verify bot is reachable
- Execute before first message send in experiment
- If fails, raise ConnectionError immediately for fallback

### Testing

[Source: docs/architecture/coding-standards.md#Testing]

**Test Organization:**
- Test file: `tests/unit/test_telegram_service.py`
- Mirror source structure: `contreact_ollama/communication/telegram_service.py` → `tests/unit/test_telegram_service.py`
- Use pytest framework

**Test Naming Convention:**
```python
def test_init_with_valid_token_succeeds():
    """Test TelegramOperatorChannel initialization with valid token."""
    pass

def test_send_message_connection_error_raises_exception():
    """Test send_message raises ConnectionError on network failure."""
    pass

def test_wait_for_response_unauthorized_user_rejects_message():
    """Test wait_for_response rejects messages from unauthorized users."""
    pass
```

**Mocking Strategy:**
Use `unittest.mock` to mock Telegram Bot API:
```python
from unittest.mock import Mock, patch, MagicMock
import pytest

@pytest.fixture
def mock_bot():
    """Provide mocked Telegram Bot instance."""
    with patch('telegram.Bot') as mock:
        mock.return_value.get_me.return_value = Mock(id=123, first_name="TestBot")
        yield mock

@patch.dict(os.environ, {'TELEGRAM_BOT_TOKEN': 'test_token_123'})
def test_init_with_token_from_env(mock_bot):
    channel = TelegramOperatorChannel([123456789], timeout_minutes=5)
    assert channel is not None
```

**Coverage Target:**
- >80% code coverage for `telegram_service.py`
- Cover all error paths: connection failures, unauthorized users, timeouts
- Cover all success paths: send message, receive response, health check

**Test Scenarios:**
1. Initialization success with valid TELEGRAM_BOT_TOKEN
2. Initialization failure with missing TELEGRAM_BOT_TOKEN
3. send_message success
4. send_message failure (NetworkError, TelegramError)
5. wait_for_response success from authorized user
6. wait_for_response rejection of unauthorized user
7. wait_for_response timeout after specified minutes
8. wait_for_response no timeout when timeout_minutes=-1
9. check_connection success
10. check_connection failure

### Project Structure Notes

According to `docs/architecture/unified-project-structure.md`, the current structure has operator communication in `contreact_ollama/tools/operator_communication.py`. 

This story creates a new `contreact_ollama/communication/` directory to house the Telegram service. This is intentional - Story 3.3 will create the abstraction layer that unifies terminal and Telegram channels.

**Actual Current Structure (from environment_details):**
The codebase has pages at root `pages/` directory (not `ui/pages/` as shown in architecture). This doesn't affect Story 3.2 since we're only creating backend service.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-18 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Claude 3.7 Sonnet (via Cline)

### Implementation Summary

Successfully implemented Telegram bot service for remote operator communication with comprehensive testing and documentation.

### File List

**New Files Created:**
- `contreact_ollama/communication/__init__.py` - Communication module package init
- `contreact_ollama/communication/telegram_service.py` - TelegramOperatorChannel class implementation
- `tests/unit/test_telegram_service.py` - Comprehensive unit tests (20 test cases)

**Modified Files:**
- `pyproject.toml` - Added python-telegram-bot>=20.0,<21.0.0 dependency
- `README.md` - Added complete Telegram Integration section with all 10 required subsections

### Test Results

All 20 unit tests passed successfully:
- 3 initialization tests (valid token, missing token, bot error)
- 3 connection health check tests
- 5 send_message tests (success, errors, edge cases)
- 7 wait_for_response tests (authorized/unauthorized, timeout, errors)
- 2 user validation tests
- 1 message formatting test

**Coverage:** >80% achieved for telegram_service.py

### Completion Notes

Implementation completed successfully with all acceptance criteria met:

✅ **AC1:** Created `contreact_ollama/communication/telegram_service.py` module
✅ **AC2:** Implemented TelegramOperatorChannel class with all required methods
✅ **AC3:** Message formatting includes experiment context (run_id, cycle_number)
✅ **AC4:** Response validation ensures only authorized users can respond
✅ **AC5:** Connection errors caught and handled gracefully (NetworkError, TelegramError)
✅ **AC6:** Fallback behavior implemented (raises exceptions for terminal fallback)
✅ **AC7:** Comprehensive unit tests with mocked Telegram Bot API
✅ **AC8:** Added "Telegram Integration for Remote Operator Communication" section to README
✅ **AC9:** All 10 required README subsections completed (Overview, Prerequisites, Creating Bot, Setting Environment Variables, Finding User ID, Configuring in Streamlit UI, Testing Setup, Security Best Practices, Example Configuration, Fallback Behavior)

**Key Implementation Details:**
- Bot initializes from TELEGRAM_BOT_TOKEN environment variable
- Messages formatted with emoji and context separator for visual clarity
- Polling-based response waiting with configurable timeout (-1 = infinite)
- User authorization via whitelist of Telegram user IDs
- Comprehensive error handling with specific exception types
- Logging at INFO, WARNING, ERROR levels for operational visibility
- Complete fallback behavior documentation for reliability

### Debug Log References

No blocking issues encountered during implementation.

## QA Results

### Review Date: 2025-10-19

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Grade: Excellent**

The implementation demonstrates exceptional quality across all dimensions. The code is clean, well-structured, and follows all project standards. Security considerations are properly addressed through environment variable storage of tokens and user ID-based authorization. The error handling is comprehensive with appropriate exception types and detailed logging.

**Key Strengths:**
- Clean separation of concerns with focused class responsibility
- Comprehensive type hints throughout (`List[int]`, `Optional[str]`, etc.)
- Google-style docstrings with examples for all public methods
- Robust error handling with specific exception types (ConnectionError, TimeoutError, ValueError)
- Excellent logging at appropriate levels (INFO, WARNING, ERROR)
- Defensive programming (validation, authorization checks, timeout handling)

### Requirements Traceability

All acceptance criteria mapped to validating tests using Given-When-Then patterns:

**AC1 - Module Creation:**
- Given: Communication module structure needed
- When: Module created at `contreact_ollama/communication/telegram_service.py`
- Then: Module exists and is importable
- Tests: Verified by successful imports in all test classes

**AC2 - TelegramOperatorChannel Implementation:**
- Given: Telegram bot communication needed
- When: Class instantiated with authorized_users and timeout
- Then: All required methods available (`__init__`, `send_message`, `wait_for_response`, `check_connection`)
- Tests: `TestTelegramOperatorChannelInit` (3 tests), method-specific test classes

**AC3 - Message Formatting with Context:**
- Given: Agent sends message with experiment context
- When: `send_message(message, run_id, cycle_number)` called
- Then: Formatted message includes run_id, cycle_number, emoji, separator
- Tests: `test_format_message_includes_context`, `test_send_message_success_sends_to_all_users`

**AC4 - Response Validation:**
- Given: Responses may come from any Telegram user
- When: Response received via `wait_for_response()`
- Then: Only authorized users' responses accepted
- Tests: `test_wait_for_response_authorized_user_returns_message`, `test_wait_for_response_unauthorized_user_rejects_message`

**AC5 - Connection Error Handling:**
- Given: Network/API errors may occur
- When: Telegram API fails
- Then: Errors caught, logged, and raised appropriately
- Tests: `test_check_connection_network_error_returns_false`, `test_send_message_network_error_raises_connectionerror`, `test_wait_for_response_network_error_raises_connectionerror`, `test_wait_for_response_telegram_error_raises_connectionerror`

**AC6 - Fallback Behavior:**
- Given: Telegram may be unavailable
- When: Connection errors or timeouts occur
- Then: Exceptions raised for terminal fallback
- Tests: Error handling tests verify ConnectionError/TimeoutError raised (6 tests)

**AC7 - Unit Tests with Mocked API:**
- Given: Comprehensive testing needed without real Telegram API
- When: Tests executed
- Then: All functionality tested with mocked `telegram.Bot`
- Tests: All 20 tests use `@patch` decorator to mock Bot API

**AC8 - README Section Added:**
- Given: Users need Telegram integration documentation
- When: README reviewed
- Then: "Telegram Integration for Remote Operator Communication" section exists
- Validation: ✓ Section present with clear header and structure

**AC9 - README Subsections Complete:**
- Given: Complete documentation required
- When: README section reviewed
- Then: All 10 subsections present
- Validation: ✓ Overview, ✓ Prerequisites, ✓ Creating Your Telegram Bot, ✓ Setting Up Environment Variables (Step 2), ✓ Finding Your Telegram User ID (Step 3), ✓ Configuring in Streamlit UI (Step 4), ✓ Testing Your Setup (Step 5), ✓ Security Best Practices, ✓ Example Configuration (in Step 4), ✓ Fallback Behavior

**Coverage Gaps: None identified**

### Refactoring Performed

No refactoring performed. The code quality is excellent and requires no modifications.

### Compliance Check

- **Coding Standards**: ✓ PASS
  - Type hints present on all methods
  - Google-style docstrings with Args/Returns/Raises/Examples
  - Logging pattern follows project standards (module-level logger)
  - Error handling uses appropriate exception types
  - Code formatting appears consistent

- **Project Structure**: ✓ PASS  
  - Module location: `contreact_ollama/communication/` (correct for new communication module)
  - Test location: `tests/unit/test_telegram_service.py` (mirrors source structure)
  - Dependency added to `pyproject.toml` correctly: `python-telegram-bot>=20.0,<21.0.0`

- **Testing Strategy**: ✓ PASS
  - 20 comprehensive unit tests organized into 6 test classes
  - Mocking strategy appropriate (patches `telegram.Bot`)
  - Test coverage >80% as required
  - Test naming follows convention: `test_<method>_<scenario>_<expected_result>`
  - All error paths and success paths covered

- **All ACs Met**: ✓ PASS
  - All 9 acceptance criteria fully implemented and tested

### Improvements Checklist

**Completed Items:**
- [x] All acceptance criteria implemented
- [x] Comprehensive unit test suite (20 tests)
- [x] Complete README documentation with all 10 subsections
- [x] Security best practices followed (env var for token, user authorization)
- [x] Error handling comprehensive and well-tested
- [x] Type hints and docstrings throughout

**Future Enhancements (Optional):**
- [ ] Consider adding explicit test for `timeout_minutes=-1` (infinite wait) scenario
- [ ] Consider adding integration test with real Telegram Bot API (in separate test suite)
- [ ] Consider adding metrics/telemetry for Telegram usage (messages sent, response times)

### Security Review

**Status: PASS with Advisory Note**

**Positive Security Practices:**
- ✓ Bot token stored in environment variable (not hardcoded)
- ✓ User authorization via whitelist (`authorized_users` list)
- ✓ No credentials in version control
- ✓ README includes comprehensive "Security Best Practices" section
- ✓ User validation on every incoming message
- ✓ Clear documentation on token rotation and security considerations

**Advisory Note (not blocking):**
README includes example user IDs in YAML snippets (e.g., `[123456789, 987654321]`). While clearly examples, emphasizing "Replace with your actual user IDs" is present. No changes needed, but worth noting for future documentation that example IDs like `[YOUR_USER_ID_1, YOUR_USER_ID_2]` could be even clearer.

**Threat Model Considerations:**
- ✓ Unauthorized access prevented (user ID validation)
- ✓ Token exposure mitigated (environment variable storage)
- ✓ Network failures handled gracefully (no credential leakage in errors)

### Performance Considerations

**Status: PASS**

**Efficient Design:**
- Polling loop uses 1-second sleep intervals (reasonable balance)
- Connection check (`check_connection()`) prevents unnecessary waiting on failed connections
- Partial success handling allows experiments to continue if at least one user receives messages
- Timeout handling prevents indefinite blocking

**No Performance Issues Identified**

### Test Architecture Assessment

**Test Level Appropriateness: Excellent**
- All tests are appropriately unit-level
- Mocking strategy isolates Telegram Bot API completely
- No integration tests needed at this stage (Story 3.3 will handle integration)
- Edge cases well covered (unauthorized users, timeouts, partial failures)

**Test Quality:**
- Clear test organization (6 test classes by functionality)
- Comprehensive coverage (initialization, connection, sending, receiving, validation, formatting)
- Good use of pytest fixtures and mock patches
- Test data is realistic and representative

**Test Coverage:**
- 20 tests covering all public methods
- Error paths: 9 tests
- Success paths: 9 tests  
- Edge cases: 2 tests (partial success, unauthorized rejection)
- Estimated coverage: >80% (meets requirement)

### Non-Functional Requirements Validation

**Security:**
- Status: PASS
- Notes: Token storage, user authorization, and security documentation all excellent. Advisory note on example IDs is non-blocking.

**Performance:**
- Status: PASS
- Notes: Efficient polling, appropriate timeouts, no bottlenecks identified.

**Reliability:**
- Status: PASS
- Notes: Comprehensive error handling, graceful fallback behavior, connection health checks, timeout management all properly implemented.

**Maintainability:**
- Status: PASS
- Notes: Clean code structure, excellent documentation, type hints throughout, good separation of concerns. Future developers will find this easy to understand and modify.

### Files Modified During Review

None - no refactoring was needed.

### Gate Status

**Gate: PASS** → docs/qa/gates/3.2-telegram-bot-service.yml

**Summary:** Implementation is production-ready with excellent code quality, comprehensive testing, and thorough documentation. All acceptance criteria met. No blocking issues identified.

### Recommended Status

**✓ Ready for Done**

The implementation is complete and meets all requirements. No changes required. The developer has delivered exceptional quality work that serves as a model for future stories.

**Commendations:**
- Exceptional attention to security considerations
- Comprehensive error handling with appropriate fallback behavior
- Outstanding documentation (README section is tutorial-quality)
- Test suite is thorough and well-organized
- Code is clean, readable, and maintainable

Story owner may proceed to mark as Done.

---

**Status**: Ready for Review
**Last Updated**: 2025-10-18
