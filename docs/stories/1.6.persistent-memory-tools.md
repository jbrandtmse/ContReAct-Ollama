# Story 1.6: Implement Persistent Memory Tools

**Status**: Ready

---

## Story

**As a** Researcher,
**I want** the agent to have access to a persistent key-value memory store,
**so that** it can retain information across multiple cycles.

---

## Acceptance Criteria

1. The TinyDB database is initialized in `data/memory.db` on first use if it doesn't exist
2. A `MemoryTools` class is implemented with `write`, `read`, `list`, `delete`, and `pattern_search` methods
3. These methods correctly interact with a file-based database (TinyDB or SQLite)
4. A `ToolDispatcher` is implemented that can receive a tool name and arguments and invoke the corresponding method in the `MemoryTools` class

---

## Tasks / Subtasks

- [ ] **Task 1: Create MemoryTools Class** (AC: 1, 2, 3)
  - [ ] Create file `contreact_ollama/tools/memory_tools.py`
  - [ ] Implement `__init__(db_path: str, run_id: str)` method
  - [ ] Initialize TinyDB connection
  - [ ] Ensure run_id isolation for multi-tenant usage
  - [ ] Add class docstring with usage examples

- [ ] **Task 2: Implement write() Method** (AC: 2, 3)
  - [ ] Implement `write(key: str, value: str) -> str` method
  - [ ] Upsert operation (insert or update if key exists)
  - [ ] Scope to current run_id
  - [ ] Return confirmation message
  - [ ] Add comprehensive docstring

- [ ] **Task 3: Implement read() Method** (AC: 2, 3)
  - [ ] Implement `read(key: str) -> str` method
  - [ ] Query by run_id and key
  - [ ] Return value if found
  - [ ] Return error message if key not found
  - [ ] Add docstring with error cases

- [ ] **Task 4: Implement list() Method** (AC: 2, 3)
  - [ ] Implement `list() -> str` method
  - [ ] Query all keys for current run_id
  - [ ] Return comma-separated string of keys
  - [ ] Return empty message if no keys exist
  - [ ] Add docstring

- [ ] **Task 5: Implement delete() and pattern_search() Methods** (AC: 2, 3)
  - [ ] Implement `delete(key: str) -> str` method
  - [ ] Implement `pattern_search(pattern: str) -> str` method
  - [ ] Use TinyDB query API for pattern matching
  - [ ] Return appropriate confirmation/result messages
  - [ ] Add docstrings

- [ ] **Task 6: Create ToolDispatcher Class** (AC: 4)
  - [ ] Create file `contreact_ollama/tools/tool_dispatcher.py`
  - [ ] Implement `__init__(memory_tools: MemoryTools)` method
  - [ ] Create tool registry dictionary
  - [ ] Implement `dispatch(tool_name: str, arguments: Dict) -> str` method
  - [ ] Implement `get_tool_definitions() -> List[Dict]` method
  - [ ] Add class and method docstrings

- [ ] **Task 7: Define Tool JSON Schemas** (AC: 4)
  - [ ] Define JSON schema for each tool
  - [ ] Include name, description, parameters
  - [ ] Follow JSON Schema format for Ollama
  - [ ] Add to get_tool_definitions() return value

- [ ] **Task 8: Integrate with ExperimentRunner** (AC: 1, 4)
  - [ ] Update initialize_services() to create MemoryTools
  - [ ] Create ToolDispatcher with MemoryTools instance
  - [ ] Add both to services dict
  - [ ] Pass db_path and run_id from config

- [ ] **Task 9: Testing** (AC: 1, 2, 3, 4)
  - [ ] Write unit tests for MemoryTools (all 5 methods)
  - [ ] Write unit tests for ToolDispatcher
  - [ ] Test run_id isolation
  - [ ] Test database persistence
  - [ ] Integration test with actual TinyDB file

---

## Dev Notes

### Previous Story Insights
From Story 1.5:
- JsonlLogger created and integrated with CycleOrchestrator
- ExperimentRunner.initialize_services() pattern established
- Services stored in dict and passed to components

### Data Models
**Source**: [docs/architecture/data-models.md#memoryentry]

MemoryEntry schema for TinyDB:

```python
{
    "run_id": str,  # Unique identifier for the experimental run
    "key": str,     # The key for the memory entry
    "value": str    # The value associated with the key
}
```

**Primary Key**: Combination of (run_id, key)

### Component Specifications
**Source**: [docs/architecture/components.md#7-memorytools]

Complete MemoryTools class definition:

```python
class MemoryTools:
    def __init__(self, db_path: str, run_id: str):
        """Initialize with path to database file and current run_id."""
        
    def write(self, key: str, value: str) -> str:
        """
        Write value to specified key in persistent memory.
        Overwrites if key exists.
        Returns confirmation message.
        """
        
    def read(self, key: str) -> str:
        """
        Read value associated with specified key.
        Returns value or error if key not found.
        """
        
    def list(self) -> str:
        """
        List all keys currently stored.
        Returns comma-separated string of keys.
        """
        
    def delete(self, key: str) -> str:
        """
        Delete key and its associated value.
        Returns confirmation message.
        """
        
    def pattern_search(self, pattern: str) -> str:
        """
        Search for keys containing the given pattern string.
        Returns comma-separated string of matching keys.
        """
```

**Source**: [docs/architecture/components.md#6-tooldispatcher]

Complete ToolDispatcher class definition:

```python
class ToolDispatcher:
    def __init__(self, memory_tools: MemoryTools):
        """Initialize with memory tools instance."""
        self.tools = {
            "write": memory_tools.write,
            "read": memory_tools.read,
            "list": memory_tools.list,
            "delete": memory_tools.delete,
            "pattern_search": memory_tools.pattern_search,
            "send_message_to_operator": send_message_to_operator
        }
        
    def dispatch(self, tool_name: str, arguments: Dict) -> str:
        """
        Invoke requested tool with arguments.
        
        Args:
            tool_name: Name of tool to invoke
            arguments: Dictionary of arguments for the tool
            
        Returns:
            String result from tool execution
        """
        
    def get_tool_definitions(self) -> List[Dict]:
        """Generate JSON schema definitions for all available tools."""
```

### File Locations
**Source**: [docs/architecture/unified-project-structure.md]

Exact file paths:
- **MemoryTools**: `contreact_ollama/tools/memory_tools.py`
- **ToolDispatcher**: `contreact_ollama/tools/tool_dispatcher.py`
- **Database file**: `data/memory.db` (TinyDB JSON file)
- **Update**: `contreact_ollama/core/experiment_runner.py` (initialize tools)

### Implementation Details

**MemoryTools Implementation**:

```python
from pathlib import Path
from typing import Optional
from tinydb import TinyDB, Query

class MemoryTools:
    """Encapsulate all persistent memory operations."""
    
    def __init__(self, db_path: str, run_id: str):
        """
        Initialize with path to database file and current run_id.
        
        Args:
            db_path: Path to TinyDB database file
            run_id: Current experiment run identifier for multi-tenant isolation
            
        Creates database file and parent directories if they don't exist.
        """
        self.db_path = Path(db_path)
        self.run_id = run_id
        
        # Ensure parent directory exists
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Initialize TinyDB
        self.db = TinyDB(self.db_path)
        
    def write(self, key: str, value: str) -> str:
        """
        Write value to specified key in persistent memory.
        
        Args:
            key: The key to store the value under
            value: The value to store
            
        Returns:
            Confirmation message
            
        Overwrites existing value if key already exists.
        Scoped to current run_id for isolation.
        """
        Entry = Query()
        
        # Check if entry exists
        existing = self.db.search((Entry.run_id == self.run_id) & (Entry.key == key))
        
        if existing:
            # Update existing entry
            self.db.update(
                {'value': value},
                (Entry.run_id == self.run_id) & (Entry.key == key)
            )
            return f"Updated key '{key}' with new value"
        else:
            # Insert new entry
            self.db.insert({
                'run_id': self.run_id,
                'key': key,
                'value': value
            })
            return f"Wrote value to key '{key}'"
            
    def read(self, key: str) -> str:
        """
        Read value associated with specified key.
        
        Args:
            key: The key to retrieve the value for
            
        Returns:
            The stored value, or error message if key not found
        """
        Entry = Query()
        result = self.db.search((Entry.run_id == self.run_id) & (Entry.key == key))
        
        if result:
            return result[0]['value']
        else:
            return f"Error: Key '{key}' not found"
            
    def list(self) -> str:
        """
        List all keys currently stored for this run.
        
        Returns:
            Comma-separated string of keys, or message if no keys exist
        """
        Entry = Query()
        results = self.db.search(Entry.run_id == self.run_id)
        
        if results:
            keys = [entry['key'] for entry in results]
            return ", ".join(keys)
        else:
            return "No keys stored"
            
    def delete(self, key: str) -> str:
        """
        Delete key and its associated value.
        
        Args:
            key: The key to delete
            
        Returns:
            Confirmation message
        """
        Entry = Query()
        removed = self.db.remove((Entry.run_id == self.run_id) & (Entry.key == key))
        
        if removed:
            return f"Deleted key '{key}'"
        else:
            return f"Error: Key '{key}' not found"
            
    def pattern_search(self, pattern: str) -> str:
        """
        Search for keys containing the given pattern string.
        
        Args:
            pattern: Substring to search for in keys
            
        Returns:
            Comma-separated string of matching keys, or message if no matches
        """
        Entry = Query()
        results = self.db.search(Entry.run_id == self.run_id)
        
        # Filter keys that contain the pattern
        matching_keys = [entry['key'] for entry in results if pattern in entry['key']]
        
        if matching_keys:
            return ", ".join(matching_keys)
        else:
            return f"No keys found matching pattern '{pattern}'"
```

**ToolDispatcher Implementation**:

```python
from typing import Dict, List, Any, Callable

class ToolDispatcher:
    """Manage and invoke the suite of tools available to the agent."""
    
    def __init__(self, memory_tools: 'MemoryTools'):
        """
        Initialize with memory tools instance.
        
        Args:
            memory_tools: Instance of MemoryTools for persistent storage
            
        Note:
            send_message_to_operator will be added in Story 1.7
        """
        self.memory_tools = memory_tools
        
        # Tool registry mapping tool names to functions
        self.tools: Dict[str, Callable] = {
            "write": self.memory_tools.write,
            "read": self.memory_tools.read,
            "list": self.memory_tools.list,
            "delete": self.memory_tools.delete,
            "pattern_search": self.memory_tools.pattern_search,
            # send_message_to_operator will be added in Story 1.7
        }
        
    def dispatch(self, tool_name: str, arguments: Dict[str, Any]) -> str:
        """
        Invoke requested tool with arguments.
        
        Args:
            tool_name: Name of tool to invoke
            arguments: Dictionary of arguments for the tool
            
        Returns:
            String result from tool execution
            
        Raises:
            KeyError: If tool_name not found in registry
            TypeError: If arguments don't match tool signature
        """
        if tool_name not in self.tools:
            return f"Error: Tool '{tool_name}' not found"
            
        tool_function = self.tools[tool_name]
        
        try:
            # Call tool with unpacked arguments
            result = tool_function(**arguments)
            return result
        except TypeError as e:
            return f"Error: Invalid arguments for tool '{tool_name}': {e}"
        except Exception as e:
            return f"Error executing tool '{tool_name}': {e}"
            
    def get_tool_definitions(self) -> List[Dict[str, Any]]:
        """
        Generate JSON schema definitions for all available tools.
        
        Returns:
            List of tool definitions in JSON Schema format for Ollama
        """
        return [
            {
                "type": "function",
                "function": {
                    "name": "write",
                    "description": "Write a value to persistent memory under a specified key. Overwrites if key exists.",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "key": {
                                "type": "string",
                                "description": "The key to store the value under"
                            },
                            "value": {
                                "type": "string",
                                "description": "The value to store"
                            }
                        },
                        "required": ["key", "value"]
                    }
                }
            },
            {
                "type": "function",
                "function": {
                    "name": "read",
                    "description": "Read a value from persistent memory by key.",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "key": {
                                "type": "string",
                                "description": "The key to retrieve the value for"
                            }
                        },
                        "required": ["key"]
                    }
                }
            },
            {
                "type": "function",
                "function": {
                    "name": "list",
                    "description": "List all keys currently stored in persistent memory.",
                    "parameters": {
                        "type": "object",
                        "properties": {},
                        "required": []
                    }
                }
            },
            {
                "type": "function",
                "function": {
                    "name": "delete",
                    "description": "Delete a key and its associated value from persistent memory.",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "key": {
                                "type": "string",
                                "description": "The key to delete"
                            }
                        },
                        "required": ["key"]
                    }
                }
            },
            {
                "type": "function",
                "function": {
                    "name": "pattern_search",
                    "description": "Search for keys in persistent memory that contain a specific pattern.",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "pattern": {
                                "type": "string",
                                "description": "Substring to search for in keys"
                            }
                        },
                        "required": ["pattern"]
                    }
                }
            }
        ]
```

### ExperimentRunner Integration

Update `initialize_services()`:

```python
def initialize_services(self) -> dict:
    """
    Initialize all required services (Ollama, Logger, Tools, etc.).
    
    Returns:
        Dictionary containing initialized service instances
    """
    services = {}
    
    # Initialize Ollama interface
    host = self.config.ollama_client_config.get('host', 'http://localhost:11434')
    ollama_interface = OllamaInterface(host=host)
    ollama_interface.verify_model_availability(self.config.model_name)
    services['ollama'] = ollama_interface
    
    # Initialize logger
    log_file_path = f"logs/{self.config.run_id}.jsonl"
    logger = JsonlLogger(log_file_path)
    services['logger'] = logger
    
    # Initialize memory tools
    db_path = "data/memory.db"
    memory_tools = MemoryTools(db_path=db_path, run_id=self.config.run_id)
    services['memory_tools'] = memory_tools
    
    # Initialize tool dispatcher
    tool_dispatcher = ToolDispatcher(memory_tools=memory_tools)
    services['tool_dispatcher'] = tool_dispatcher
    
    # NOTE: SimilarityMonitor will be added in Story 1.10
    
    return services
```

### Import Organization
**Source**: [docs/architecture/coding-standards.md#3-code-formatting]

For `contreact_ollama/tools/memory_tools.py`:
```python
# Standard library imports
from pathlib import Path
from typing import Optional

# Third-party imports
from tinydb import TinyDB, Query

# Local application imports
# (none for this file)
```

For `contreact_ollama/tools/tool_dispatcher.py`:
```python
# Standard library imports
from typing import Dict, List, Any, Callable

# Third-party imports
# (none for this file)

# Local application imports
from contreact_ollama.tools.memory_tools import MemoryTools
```

### Coding Standards
**Source**: [docs/architecture/coding-standards.md]

**Type Hints Required**:
- All method parameters and return types
- Use `str` for all memory operations (keys, values, results)
- Use `Dict[str, Any]` for tool arguments
- Use `List[Dict[str, Any]]` for tool definitions

**Docstrings Required**:
- Class-level docstrings for both classes
- Method docstrings with Args, Returns, Raises sections
- Explain run_id isolation in MemoryTools.__init__

**Error Handling**:
- Return error messages as strings (don't raise exceptions)
- Gracefully handle missing keys
- Handle invalid tool names
- Handle argument mismatches

### Database Schema Validation

TinyDB stores data as JSON in `data/memory.db`. Example content:

```json
{
  "_default": {
    "1": {"run_id": "llama3-experiment-001", "key": "task_status", "value": "in_progress"},
    "2": {"run_id": "llama3-experiment-001", "key": "findings", "value": "discovered pattern X"},
    "3": {"run_id": "different-run", "key": "task_status", "value": "complete"}
  }
}
```

Run-id isolation ensures experiments don't interfere with each other.

---

## Testing

**Source**: [docs/architecture/coding-standards.md#8-testing-standards]

### Test Standards for This Story
- **Test Coverage Target**: >80% code coverage
- **Test Framework**: pytest 8.2.2+
- **Test File Locations**: 
  - `tests/unit/test_memory_tools.py`
  - `tests/unit/test_tool_dispatcher.py`

### Testing Requirements for Story 1.6

**Unit Tests** (`tests/unit/test_memory_tools.py`):

1. **test_init_creates_database_file**
   - Create MemoryTools with test db path
   - Assert database file created
   - Assert parent directories created

2. **test_write_creates_new_entry**
   - Call write(key, value)
   - Assert entry exists in database
   - Assert confirmation message returned

3. **test_write_updates_existing_entry**
   - Write same key twice with different values
   - Assert only one entry exists
   - Assert value is updated

4. **test_read_returns_value**
   - Write key-value pair
   - Call read(key)
   - Assert correct value returned

5. **test_read_key_not_found_returns_error**
   - Call read() with non-existent key
   - Assert error message returned

6. **test_list_returns_all_keys**
   - Write multiple key-value pairs
   - Call list()
   - Assert all keys in comma-separated result

7. **test_list_empty_returns_message**
   - Call list() with empty database
   - Assert "No keys stored" message

8. **test_delete_removes_entry**
   - Write key-value pair
   - Call delete(key)
   - Assert entry removed from database
   - Assert confirmation message

9. **test_pattern_search_finds_matching_keys**
   - Write keys: "task_1", "task_2", "note_1"
   - Call pattern_search("task")
   - Assert "task_1, task_2" returned

10. **test_run_id_isolation**
    - Create two MemoryTools instances with different run_ids
    - Write to both
    - Assert each only sees own data

**Unit Tests** (`tests/unit/test_tool_dispatcher.py`):

1. **test_dispatch_calls_correct_tool**
   - Mock MemoryTools methods
   - Call dispatch("write", {"key": "test", "value": "data"})
   - Assert write method called with correct args

2. **test_dispatch_invalid_tool_returns_error**
   - Call dispatch("invalid_tool", {})
   - Assert error message about tool not found

3. **test_dispatch_invalid_arguments_returns_error**
   - Call dispatch("write", {"wrong_param": "value"})
   - Assert error message about invalid arguments

4. **test_get_tool_definitions_returns_all_tools**
   - Call get_tool_definitions()
   - Assert 5 tool definitions returned (write, read, list, delete, pattern_search)
   - Assert each has proper JSON Schema structure

5. **test_get_tool_definitions_follows_ollama_format**
   - Call get_tool_definitions()
   - Validate structure matches Ollama function calling schema
   - Assert required fields present (type, function, name, parameters)

**Integration Tests** (`tests/integration/test_memory_persistence.py`):

1. **test_memory_persists_across_instances**
   - Create MemoryTools, write data, close
   - Create new MemoryTools instance (same db_path, run_id)
   - Read data
   - Assert data persisted

2. **test_dispatcher_executes_memory_operations**
   - Create real ToolDispatcher and MemoryTools
   - Dispatch write operation
   - Dispatch read operation
   - Assert operations execute correctly

**Test Fixture Example**:

```python
import pytest
import tempfile
from pathlib import Path
from contreact_ollama.tools.memory_tools import MemoryTools

@pytest.fixture
def temp_db():
    """Provide temporary database path."""
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = Path(tmpdir) / "test_memory.db"
        yield str(db_path)

@pytest.fixture
def memory_tools(temp_db):
    """Provide MemoryTools instance with temp database."""
    return MemoryTools(db_path=temp_db, run_id="test-run")

def test_write_creates_new_entry(memory_tools):
    result = memory_tools.write("test_key", "test_value")
    
    assert "Wrote value to key 'test_key'" in result
    
    # Verify in database
    read_result = memory_tools.read("test_key")
    assert read_result == "test_value"
```

### Manual Testing Checklist

Before marking story complete:
- [ ] Create temporary Python script to test memory operations
- [ ] Test write() - verify value stored
- [ ] Test read() - verify value retrieved
- [ ] Test list() - verify all keys shown
- [ ] Test delete() - verify key removed
- [ ] Test pattern_search() - verify matching keys found
- [ ] Verify database file created at `data/memory.db`
- [ ] Open database file, verify JSON structure
- [ ] Test run_id isolation with two different run_ids
- [ ] Test ToolDispatcher.dispatch() with each tool
- [ ] Verify tool definitions match Ollama schema

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-08 | 1.0 | Initial story creation | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by dev agent during implementation*

### Debug Log References
*To be populated by dev agent during implementation*

### Completion Notes List
*To be populated by dev agent during implementation*

### File List
*To be populated by dev agent during implementation*

---

## QA Results
*To be populated by QA agent after implementation*
