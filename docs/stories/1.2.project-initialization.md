# Story 1.2: Project Initialization and Configuration Loading

**Status**: Done

---

## Story

**As a** Researcher,
**I want** a script that can initialize the project and load an experiment configuration from a YAML file,
**so that** I can define and manage experiments reproducibly.

---

## Acceptance Criteria

1. A `run_experiment.py` script exists in the project's root directory (specifically in `scripts/` directory)
2. The script can be executed with a `--config` argument pointing to a valid `.yaml` file
3. Upon execution, the script successfully parses the YAML file and prints its contents to the console
4. If the script is run with a path to a non-existent file, it exits gracefully with an informative error message

---

## Tasks / Subtasks

- [x] **Task 1: Create ExperimentConfig Dataclass** (AC: 3)
  - [x] Create file `contreact_ollama/core/config.py`
  - [x] Define `ExperimentConfig` dataclass with all required fields
  - [x] Add type hints for all fields
  - [x] Add docstring explaining purpose and field meanings
  - [x] Import required types (Dict, Any from typing)

- [x] **Task 2: Create Basic ExperimentRunner Class** (AC: 1, 3, 4)
  - [x] Create file `contreact_ollama/core/experiment_runner.py`
  - [x] Implement `__init__(self, config_path: str)` method
  - [x] Implement `load_config(self) -> ExperimentConfig` method with YAML parsing
  - [x] Add file existence validation with clear error message
  - [x] Add YAML parsing error handling
  - [x] Add configuration validation (check required fields exist)
  - [x] Add class and method docstrings following Google style

- [x] **Task 3: Create run_experiment.py CLI Script** (AC: 1, 2)
  - [x] Create file `scripts/run_experiment.py`
  - [x] Add argparse argument parser with `--config` parameter
  - [x] Import ExperimentRunner from contreact_ollama.core
  - [x] Instantiate ExperimentRunner with config path from CLI
  - [x] Call load_config() and print parsed configuration
  - [x] Add if __name__ == "__main__": guard
  - [x] Add script-level docstring explaining usage

- [x] **Task 4: Create Sample Configuration File** (AC: 2)
  - [x] Create `configs/sample-config.yaml` with all required fields
  - [x] Include comments explaining each field
  - [x] Use realistic example values
  - [x] Follow YAML best practices (proper indentation, spacing)

- [x] **Task 5: Error Handling Implementation** (AC: 4)
  - [x] Catch FileNotFoundError for missing config files
  - [x] Catch yaml.YAMLError for malformed YAML
  - [x] Catch KeyError/TypeError for missing required fields
  - [x] Print clear, actionable error messages
  - [x] Exit with non-zero status code on errors

- [x] **Task 6: Manual Testing and Verification** (AC: 1, 2, 3, 4)
  - [x] Test with valid config file: `python scripts/run_experiment.py --config configs/sample-config.yaml`
  - [x] Verify config contents print to console
  - [x] Test with non-existent file: `python scripts/run_experiment.py --config nonexistent.yaml`
  - [x] Verify graceful error message appears
  - [x] Test with malformed YAML file
  - [x] Verify all error scenarios provide helpful messages

---

## Dev Notes

### Previous Story Insights
From Story 1.1, the complete project structure was created including:
- `scripts/` directory for CLI entry points
- `contreact_ollama/core/` package for core application logic
- `configs/` directory for experiment configurations

### Data Models to Implement
**Source**: [docs/architecture/data-models.md#experimentconfig]

Complete ExperimentConfig dataclass definition:

```python
from dataclasses import dataclass
from typing import Dict, Any

@dataclass
class ExperimentConfig:
    """Configuration for a single experimental run."""
    
    run_id: str  # Unique identifier for this specific run
    model_name: str  # Model tag as recognized by local Ollama server
    cycle_count: int  # Total number of cycles to run (e.g., 10)
    ollama_client_config: Dict[str, Any]  # Configuration for Ollama client
    model_options: Dict[str, Any]  # Parameters for LLM generation
```

**Model Options Schema** (nested within model_options field):
```python
{
    "seed": int,  # Random number seed for reproducibility
    "temperature": float,  # Temperature of the model (higher = more creative)
    "top_p": float,  # Works with top_k for nucleus sampling
    "num_predict": int,  # Maximum tokens to generate (-1 = no limit)
    "repeat_last_n": int,  # How far back model looks to prevent repetition
    "repeat_penalty": float,  # How strongly to penalize repetitions
    "num_ctx": int  # Context window size
}
```

### Component Specifications
**Source**: [docs/architecture/components.md#1-experimentrunner]

ExperimentRunner class methods to implement:

```python
class ExperimentRunner:
    def __init__(self, config_path: str):
        """Initialize runner with path to configuration file."""
        
    def load_config(self) -> ExperimentConfig:
        """Load and validate YAML configuration file."""
        
    def initialize_services(self) -> dict:
        """Initialize all required services (Ollama, Logger, Tools, etc.)."""
        # NOTE: This method will be implemented in later stories
        
    def run(self) -> None:
        """Execute the complete experimental run."""
        # NOTE: This method will be implemented in later stories
```

**For Story 1.2**, only implement:
- `__init__(self, config_path: str)` - Store config path
- `load_config(self) -> ExperimentConfig` - Parse and validate YAML, return ExperimentConfig

Do NOT implement `initialize_services()` or `run()` yet - those come in later stories.

### File Locations
**Source**: [docs/architecture/unified-project-structure.md]

Exact file paths to create:
- **Script**: `scripts/run_experiment.py` (CLI entry point)
- **Config dataclass**: `contreact_ollama/core/config.py`
- **ExperimentRunner**: `contreact_ollama/core/experiment_runner.py`
- **Sample config**: `configs/sample-config.yaml` (example configuration)

### Sample Configuration File Structure

**File**: `configs/sample-config.yaml`

```yaml
# Experiment Configuration for ContReAct-Ollama Platform
# This file defines parameters for a single experimental run

# Unique identifier for this experimental run
run_id: "llama3-experiment-001"

# Model tag as recognized by local Ollama server
# Use 'ollama list' to see available models
model_name: "llama3:latest"

# Total number of operational cycles to execute
cycle_count: 10

# Ollama client configuration
ollama_client_config:
  host: "http://localhost:11434"  # Ollama server URL

# LLM generation parameters
# See Ollama documentation for details on each parameter
model_options:
  seed: 42                    # Random seed for reproducibility
  temperature: 0.7            # Creativity level (0.0-1.0, higher = more creative)
  top_p: 0.9                  # Nucleus sampling threshold
  num_predict: -1             # Max tokens to generate (-1 = no limit)
  repeat_last_n: 64           # Look-back window for repetition penalty
  repeat_penalty: 1.1         # Penalty multiplier for repeated tokens
  num_ctx: 4096               # Context window size in tokens
```

### CLI Script Structure

**File**: `scripts/run_experiment.py`

Required elements:
1. **Shebang** (optional but recommended): `#!/usr/bin/env python3`
2. **Module docstring** explaining script purpose and usage
3. **Imports**: argparse, sys, ExperimentRunner
4. **Argument parser**: 
   - `--config` argument (required)
   - Help text explaining expected YAML file path
5. **Main execution block**:
   - Parse arguments
   - Create ExperimentRunner instance
   - Call load_config() and capture result
   - Print configuration to console (use pprint or formatted output)
   - Exit with code 0 on success
6. **Error handling**:
   - Catch exceptions from load_config()
   - Print clear error message to stderr
   - Exit with code 1 on failure

### Error Handling Requirements
**Source**: [docs/architecture/coding-standards.md#5-error-handling]

Specific exception types to handle:

1. **FileNotFoundError**: Config file doesn't exist
   - Message: `"Error: Configuration file not found: {config_path}"`
   - Suggestion: `"Please check the file path and try again."`

2. **yaml.YAMLError**: Malformed YAML syntax
   - Message: `"Error: Invalid YAML syntax in configuration file: {error_details}"`
   - Suggestion: `"Please validate your YAML syntax and try again."`

3. **KeyError**: Missing required field in config
   - Message: `"Error: Missing required field in configuration: {field_name}"`
   - Suggestion: `"Required fields: run_id, model_name, cycle_count, ollama_client_config, model_options"`

4. **TypeError/ValueError**: Invalid field value type
   - Message: `"Error: Invalid value for field {field_name}: {error_details}"`
   - Suggestion: `"Please check the sample configuration for expected value types."`

**Never use bare except** - always catch specific exception types.

### Import Organization
**Source**: [docs/architecture/coding-standards.md#3-code-formatting]

For `scripts/run_experiment.py`:
```python
# Standard library imports
import argparse
import sys
from pathlib import Path

# Third-party imports
# (none for this story)

# Local application imports
from contreact_ollama.core.experiment_runner import ExperimentRunner
```

For `contreact_ollama/core/experiment_runner.py`:
```python
# Standard library imports
from pathlib import Path
from typing import Dict, Any

# Third-party imports
import yaml

# Local application imports
from contreact_ollama.core.config import ExperimentConfig
```

For `contreact_ollama/core/config.py`:
```python
# Standard library imports
from dataclasses import dataclass
from typing import Dict, Any
```

### Coding Standards
**Source**: [docs/architecture/coding-standards.md]

**Type Hints** (Required):
- All function parameters must have type hints
- All return types must be specified
- Use `Dict[str, Any]` for dynamic dictionary structures

**Docstrings** (Required):
- Google-style docstrings for all classes and public methods
- Include Args, Returns, and Raises sections where applicable

**Naming Conventions**:
- Class: `ExperimentRunner`, `ExperimentConfig` (PascalCase)
- Methods/functions: `load_config`, `run_experiment` (snake_case)
- Files: `experiment_runner.py`, `config.py` (snake_case)

**Example Docstring**:
```python
def load_config(self) -> ExperimentConfig:
    """
    Load and validate YAML configuration file.
    
    Returns:
        ExperimentConfig: Parsed and validated configuration object
        
    Raises:
        FileNotFoundError: If config file doesn't exist
        yaml.YAMLError: If YAML syntax is invalid
        KeyError: If required field is missing
        TypeError: If field value has incorrect type
        
    Example:
        >>> runner = ExperimentRunner("configs/sample-config.yaml")
        >>> config = runner.load_config()
        >>> print(config.run_id)
        'llama3-experiment-001'
    """
```

### Configuration Validation Logic

When loading config, validate:
1. **File exists**: Use `Path(config_path).exists()`
2. **YAML parses**: Use `yaml.safe_load()` (NOT `yaml.load()` for security)
3. **Required fields present**: Check all 5 required fields exist
4. **Field types correct** (basic validation):
   - `run_id`: str
   - `model_name`: str
   - `cycle_count`: int (and > 0)
   - `ollama_client_config`: dict
   - `model_options`: dict

**Do NOT validate**:
- Whether model exists in Ollama (Story 1.3 handles this)
- Whether Ollama server is running (Story 1.3 handles this)
- Detailed model_options parameter values (trust user input for now)

### Output Format for Console Print

When printing configuration after successful load:
```
Successfully loaded configuration:
--------------------------------------------------
Run ID: llama3-experiment-001
Model: llama3:latest
Cycle Count: 10
Ollama Host: http://localhost:11434
Model Options:
  - seed: 42
  - temperature: 0.7
  - top_p: 0.9
  - num_predict: -1
  - repeat_last_n: 64
  - repeat_penalty: 1.1
  - num_ctx: 4096
--------------------------------------------------
```

Use formatted output, not raw dataclass repr() or pprint.

---

## Testing

**Source**: [docs/architecture/coding-standards.md#8-testing-standards]

### Test Standards for This Story
- **Test Coverage Target**: >80% code coverage
- **Test Framework**: pytest 8.2.2+
- **Test File Location**: `tests/unit/`

### Testing Requirements for Story 1.2

**Unit Tests to Create** (`tests/unit/test_experiment_runner.py`):

1. **test_load_config_valid_file_returns_config**
   - Create temporary YAML file with valid config
   - Call load_config()
   - Assert ExperimentConfig returned with correct values

2. **test_load_config_missing_file_raises_error**
   - Pass path to non-existent file
   - Assert FileNotFoundError raised with expected message

3. **test_load_config_invalid_yaml_raises_error**
   - Create temporary file with malformed YAML
   - Assert yaml.YAMLError raised

4. **test_load_config_missing_required_field_raises_error**
   - Create YAML file missing required field (e.g., no run_id)
   - Assert KeyError raised with informative message

5. **test_load_config_invalid_field_type_raises_error**
   - Create YAML file with cycle_count as string instead of int
   - Assert TypeError or ValueError raised

**Integration Tests** (`tests/integration/test_cli.py`):

1. **test_cli_with_valid_config_exits_zero**
   - Run: `python scripts/run_experiment.py --config tests/fixtures/sample_config.yaml`
   - Assert exit code 0
   - Assert config printed to stdout

2. **test_cli_with_invalid_file_exits_nonzero**
   - Run: `python scripts/run_experiment.py --config nonexistent.yaml`
   - Assert exit code 1
   - Assert error message in stderr

**Test Fixtures** (`tests/fixtures/sample_config.yaml`):
- Create valid sample config for testing
- Use simple, known values for assertions

### Manual Testing Checklist

Before marking story complete, manually verify:
- [ ] `python scripts/run_experiment.py --config configs/sample-config.yaml` succeeds
- [ ] Configuration prints to console in readable format
- [ ] `python scripts/run_experiment.py --config fake.yaml` shows clear error
- [ ] Error message is helpful and actionable
- [ ] All imports work correctly
- [ ] No import errors when running script

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-08 | 1.0 | Initial story creation | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used
Claude 3.5 Sonnet (via Cline)

### Debug Log References
No debug issues encountered during implementation.

### Completion Notes List
- Successfully implemented ExperimentConfig dataclass with type hints and comprehensive docstrings
- Created ExperimentRunner class with robust error handling for file not found, YAML parsing errors, missing fields, and invalid field types
- Implemented CLI script with argparse for configuration file loading
- Created sample configuration file with detailed comments
- All error scenarios properly handled with informative messages and non-zero exit codes
- Comprehensive test suite created: 6 unit tests and 4 integration tests, all passing
- Manual testing confirmed all acceptance criteria met

### File List
**Source Files:**
- contreact_ollama/core/config.py
- contreact_ollama/core/experiment_runner.py
- scripts/run_experiment.py
- configs/sample-config.yaml

**Test Files:**
- tests/unit/test_experiment_runner.py
- tests/integration/test_cli.py
- tests/fixtures/sample_config.yaml

**Temporary Test Files:**
- configs/test-malformed.yaml (for testing error handling)

---

## QA Results

### Review Date: 2025-10-09

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Excellent implementation quality across all components. The code demonstrates strong adherence to architectural principles with clean separation of concerns (config dataclass, runner class, CLI script), comprehensive type hints, and Google-style docstrings throughout. Error handling is robust with specific exception types and actionable error messages. The implementation fully satisfies all 4 acceptance criteria with appropriate test coverage.

**Strengths:**
- Comprehensive input validation with clear, actionable error messages
- Security best practice: uses `yaml.safe_load()` instead of `yaml.load()`
- Excellent documentation with detailed docstrings including Args, Returns, Raises, and Examples
- Proper abstraction and single responsibility principle maintained throughout

### Refactoring Performed

- **File**: scripts/run_experiment.py
  - **Change**: Enhanced error handling specificity
  - **Why**: Original implementation caught all non-FileNotFoundError exceptions generically. Specific exception handling provides clearer error feedback to users.
  - **How**: Added explicit exception handlers for yaml.YAMLError, KeyError, TypeError, and ValueError, ensuring each error type provides appropriate messaging. Added yaml import to support this.

### Compliance Check

- Coding Standards: ✓ Full compliance
  - Type hints on all functions
  - Google-style docstrings complete
  - Import organization correct (standard/third-party/local)
  - Specific exception handling (no bare except)
  - Naming conventions followed (PascalCase classes, snake_case functions)
- Project Structure: ✓ All files in correct locations
- Testing Strategy: ✓ Comprehensive coverage with unit and integration tests
- All ACs Met: ✓ All 4 acceptance criteria fully implemented and tested

### Requirements Traceability

**AC1: run_experiment.py script in scripts/ directory**
- Implementation: ✓ scripts/run_experiment.py created with full CLI functionality
- Test Coverage: test_cli_with_valid_config_exits_zero, test_cli_with_invalid_file_exits_nonzero, test_cli_with_malformed_yaml_exits_nonzero, test_cli_without_config_argument_fails

**AC2: Script accepts --config argument for YAML file**
- Implementation: ✓ argparse with required --config parameter
- Test Coverage: test_cli_with_valid_config_exits_zero, test_cli_without_config_argument_fails

**AC3: Script parses YAML and prints contents**
- Implementation: ✓ ExperimentRunner.load_config() parses YAML, main() prints formatted output
- Test Coverage: test_load_config_valid_file_returns_config, test_cli_with_valid_config_exits_zero

**AC4: Graceful error handling for non-existent files**
- Implementation: ✓ FileNotFoundError with clear message and suggestion
- Test Coverage: test_load_config_missing_file_raises_error, test_cli_with_invalid_file_exits_nonzero

**Coverage Assessment:** All acceptance criteria have complete test coverage mapping.

### Test Architecture Assessment

**Test Coverage:** Comprehensive (10 tests total)
- 6 unit tests for ExperimentRunner.load_config() covering all validation scenarios
- 4 integration tests for CLI script covering success and error paths
- Estimated coverage: >85%

**Test Quality:**
- ✓ Proper test level selection (unit for business logic, integration for CLI)
- ✓ Clear naming convention: test_<method>_<scenario>_<expected_result>
- ✓ Good use of temporary files with proper cleanup
- ✓ Comprehensive edge case coverage (missing file, malformed YAML, missing fields, invalid types, boundary conditions)
- ✓ Test fixtures properly organized in tests/fixtures/

### Security Review

**Status: PASS**
- ✓ Secure YAML parsing using yaml.safe_load() (prevents code injection)
- ✓ Comprehensive input validation for all required fields
- ✓ Type checking prevents type-based vulnerabilities
- ✓ Path validation implemented with Path objects
- ✓ No security concerns identified

### Performance Considerations

**Status: PASS**
- File I/O operations are minimal and efficient
- YAML parsing is appropriate for configuration loading use case
- No performance concerns for initialization logic
- Proper resource management (file handles closed appropriately)

### Non-Functional Requirements Validation

- **Security:** PASS - Safe YAML loading, comprehensive input validation
- **Performance:** PASS - Efficient file operations, appropriate for use case
- **Reliability:** PASS - Robust error handling, all error paths tested
- **Maintainability:** PASS - Excellent documentation, clear structure, follows standards

### Files Modified During Review

- scripts/run_experiment.py - Enhanced error handling specificity

### Gate Status

Gate: **PASS** → docs/qa/gates/1.2-project-initialization.yml

**Quality Score:** 100/100

**Status Reason:** All acceptance criteria fully implemented with comprehensive test coverage. Code quality excellent with proper architecture, type hints, documentation, and error handling. Security best practices followed. No blocking issues identified.

### Recommended Status

✓ **Ready for Done** - All requirements met, excellent implementation quality, no changes required.
